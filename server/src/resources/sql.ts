// *****************************************************
// This file is auto-generated by embed-strings.
// Command: bin/./embed-strings -s ./resources/sql/ -o src/resources/sql.ts
// *****************************************************

export const memorylaneClusterQuery = `WITH
    CONSTANTS AS (
        SELECT
            $1::BIGINT            AS SEED,
            $2::INT               AS RESULT_LIMIT,
            $3::uuid[]            AS USER_IDS,
            INTERVAL '15 minutes' AS MIN_TIME_BETWEEN_PHOTOS
    ),

    cluster_data AS (
        SELECT
            c.cluster_id,
            c.cluster_start,
            c.cluster_end,
            c."ownerId"                      AS owner_id,
            JSONB_BUILD_OBJECT(
                    'cities', c.cities,
                    'states', c.states,
                    'countries', c.countries
            )                                AS cluster_location_distribution,
            c.cluster_cardinality_score_ge_0 AS cardinality_score_ge_0
        FROM asset_dbscan_clusters c
             CROSS JOIN CONSTANTS co
        WHERE
              c.cluster_cardinality_score_ge_0 >= co.RESULT_LIMIT
          AND c."ownerId" = ANY (co.USER_IDS)
    ),

    asset_data AS (
        SELECT
            ad.id,
            ad.ts,
            ad.cluster_id,
            ad."ownerId"                             AS owner_id,
            COALESCE(ad.normalized_quality_score, 0) AS normalized_quality_score
        FROM asset_analysis ad
             CROSS JOIN CONSTANTS co
        WHERE
              COALESCE(ad.normalized_quality_score, 0) >= 0
          AND ad."ownerId" = ANY (co.USER_IDS)
    ),

    selected_cluster AS (
        WITH
            weighted_data AS (
                SELECT
                    d.cluster_id,
                    d.owner_id,
                    d.cluster_start,
                    d.cluster_end,
                    d.cluster_location_distribution,
                    SQRT(d.cardinality_score_ge_0) AS weight
                FROM cluster_data d
                     CROSS JOIN CONSTANTS c
                WHERE
                    d.cardinality_score_ge_0 >= c.RESULT_LIMIT
            ),

            weighted_data_running_sum AS (
                SELECT
                    wd.*,
                    SUM(wd.weight) OVER ()                       AS total_weight,
                    SUM(wd.weight) OVER (ORDER BY wd.cluster_id) AS right_cumulative
                FROM weighted_data wd
            ),

            weighted_data_bands AS (
                SELECT
                    wdrs.*,
                    COALESCE(LAG(wdrs.right_cumulative) OVER (ORDER BY wdrs.cluster_id), 0) AS left_cumulative
                FROM weighted_data_running_sum wdrs
            )

        SELECT
            wdb.cluster_id,
            wdb.owner_id,
            wdb.cluster_start,
            wdb.cluster_end,
            wdb.cluster_location_distribution
        FROM weighted_data_bands wdb
             CROSS JOIN CONSTANTS c
        WHERE
            (c.SEED % ROUND(1367 * wdb.total_weight)::BIGINT)
                BETWEEN 1367 * wdb.left_cumulative AND 1367 * wdb.right_cumulative
        LIMIT 1
    ),

    selected_assets AS (
        WITH
            weighted_data AS (
                SELECT
                    d.id,
                    d.ts,
                    1 + d.normalized_quality_score AS weight
                FROM asset_data d
                     JOIN selected_cluster USING (cluster_id, owner_id)
            ),

            weighted_data_running_sum AS (
                SELECT
                    wd.*,
                    SUM(wd.weight) OVER ()               AS total_weight,
                    SUM(wd.weight) OVER (ORDER BY wd.ts) AS right_cumulative
                FROM weighted_data wd
            ),

            weighted_data_bands AS (
                SELECT
                    wdrs.*,
                    COALESCE(LAG(wdrs.right_cumulative) OVER (ORDER BY wdrs.ts), 0) AS left_cumulative
                FROM weighted_data_running_sum wdrs
            ),

            candidates AS (
                SELECT
                    i AS draw_number,
                    wb.id,
                    wb.ts
                FROM weighted_data_bands wb
                     CROSS JOIN CONSTANTS c
                     JOIN GENERATE_SERIES(0, 2 * c.RESULT_LIMIT) i
                          ON (((c.SEED # i)::BIGINT * 73244475::BIGINT) % 4294967296::BIGINT) % ROUND(1367 * wb.total_weight)::BIGINT
                              BETWEEN 1367 * wb.left_cumulative AND 1367 * wb.right_cumulative
            ),

            candidates_with_lookback AS (
                SELECT
                    c.draw_number,
                    c.id,
                    c.ts,
                    LAG(c.ts) OVER (ORDER BY c.ts, c.draw_number) AS prev_ts
                FROM candidates c
            ),

            filtered_candidates AS (
                SELECT
                    ROW_NUMBER() OVER (ORDER BY cwl.draw_number) AS draw_number,
                    cwl.id,
                    cwl.ts
                FROM candidates_with_lookback cwl
                     CROSS JOIN CONSTANTS c
                WHERE
                     cwl.prev_ts IS NULL
                  OR cwl.ts - cwl.prev_ts >= c.MIN_TIME_BETWEEN_PHOTOS
            )

        SELECT
            saf.draw_number,
            saf.id,
            saf.ts
        FROM filtered_candidates saf
             CROSS JOIN CONSTANTS c
        WHERE
            saf.draw_number <= c.RESULT_LIMIT
    )

SELECT
    sa.id,
    s.cluster_id,
    s.cluster_start,
    s.cluster_end,
    s.cluster_location_distribution
FROM selected_assets sa
     CROSS JOIN selected_cluster s
ORDER BY sa.ts`;

export const memorylanePersonQuery = `WITH
    CONSTANTS AS (
        SELECT
            $1::BIGINT            AS SEED,
            $2::INT               AS RESULT_LIMIT,
            $3::uuid[]            AS USER_IDS,
            INTERVAL '15 minutes' AS MIN_TIME_BETWEEN_PHOTOS
    ),

    person_data AS (
        SELECT
            p.id                  AS person_id,
            p.name                AS person_name,
            p."ownerId"           AS owner_id,
            COUNT(DISTINCT af.id) AS cardinality_score_ge_0
        FROM person p
             JOIN asset_faces af ON p.id = af."personId"
             JOIN asset_analysis aa ON af."assetId" = aa.id
             CROSS JOIN CONSTANTS co
        WHERE
              p."ownerId" = ANY (co.USER_IDS)
          AND COALESCE(aa.normalized_quality_score, 0) >= 0
        GROUP BY p.id, p.name
    ),

    asset_data AS (
        SELECT
            ad.id,
            ad.ts,
            af."personId"                            AS person_id,
            ad."ownerId"                             AS owner_id,
            COALESCE(ad.normalized_quality_score, 0) AS normalized_quality_score
        FROM asset_analysis ad
             JOIN asset_faces af ON ad.id = af."assetId"
             CROSS JOIN CONSTANTS co
        WHERE
              COALESCE(ad.normalized_quality_score, 0) >= 0
          AND ad."ownerId" = ANY (co.USER_IDS)
    ),

    selected_person AS (
        WITH
            weighted_data AS (
                SELECT
                    d.person_id,
                    d.person_name,
                    d.owner_id,
                    SQRT(d.cardinality_score_ge_0) AS weight
                FROM person_data d
                     CROSS JOIN CONSTANTS c
                WHERE
                    d.cardinality_score_ge_0 >= c.RESULT_LIMIT
            ),

            weighted_data_running_sum AS (
                SELECT
                    wd.*,
                    SUM(wd.weight) OVER ()                      AS total_weight,
                    SUM(wd.weight) OVER (ORDER BY wd.person_id) AS right_cumulative
                FROM weighted_data wd
            ),

            weighted_data_bands AS (
                SELECT
                    wdrs.*,
                    COALESCE(LAG(wdrs.right_cumulative) OVER (ORDER BY wdrs.person_id), 0) AS left_cumulative
                FROM weighted_data_running_sum wdrs
            )

        SELECT
            wdb.person_id,
            wdb.person_name,
            wdb.owner_id
        FROM weighted_data_bands wdb
             CROSS JOIN CONSTANTS c
        WHERE
            (c.SEED % ROUND(1367 * wdb.total_weight)::BIGINT)
                BETWEEN 1367 * wdb.left_cumulative AND 1367 * wdb.right_cumulative
        LIMIT 1
    ),

    selected_assets AS (
        WITH
            weighted_data AS (
                SELECT
                    d.id,
                    d.ts,
                    1 + d.normalized_quality_score AS weight
                FROM asset_data d
                     JOIN selected_person USING (person_id, owner_id)
            ),

            weighted_data_running_sum AS (
                SELECT
                    wd.*,
                    SUM(wd.weight) OVER ()               AS total_weight,
                    SUM(wd.weight) OVER (ORDER BY wd.ts) AS right_cumulative
                FROM weighted_data wd
            ),

            weighted_data_bands AS (
                SELECT
                    wdrs.*,
                    COALESCE(LAG(wdrs.right_cumulative) OVER (ORDER BY wdrs.ts), 0) AS left_cumulative
                FROM weighted_data_running_sum wdrs
            ),

            candidates AS (
                SELECT
                    i AS draw_number,
                    wb.id,
                    wb.ts
                FROM weighted_data_bands wb
                     CROSS JOIN CONSTANTS c
                     JOIN GENERATE_SERIES(0, 2 * c.RESULT_LIMIT) i
                          ON (((c.SEED # i)::BIGINT * 73244475::BIGINT) % 4294967296::BIGINT) % ROUND(1367 * wb.total_weight)::BIGINT
                              BETWEEN 1367 * wb.left_cumulative AND 1367 * wb.right_cumulative
            ),

            candidates_with_lookback AS (
                SELECT
                    c.draw_number,
                    c.id,
                    c.ts,
                    LAG(c.ts) OVER (ORDER BY c.ts, c.draw_number) AS prev_ts
                FROM candidates c
            ),

            filtered_candidates AS (
                SELECT
                    ROW_NUMBER() OVER (ORDER BY cwl.draw_number) AS draw_number,
                    cwl.id,
                    cwl.ts
                FROM candidates_with_lookback cwl
                     CROSS JOIN CONSTANTS c
                WHERE
                     cwl.prev_ts IS NULL
                  OR cwl.ts - cwl.prev_ts >= c.MIN_TIME_BETWEEN_PHOTOS
            )

        SELECT
            saf.draw_number,
            saf.id,
            saf.ts
        FROM filtered_candidates saf
             CROSS JOIN CONSTANTS c
        WHERE
            saf.draw_number <= c.RESULT_LIMIT
    )

SELECT
    sa.id,
    s.person_id,
    s.person_name
FROM selected_assets sa
     CROSS JOIN selected_person s
ORDER BY sa.draw_number`;

export const memorylaneRecentHighlightsQuery = `WITH
    CONSTANTS AS (
        SELECT
            $1::BIGINT          AS SEED,
            $2::INT             AS RESULT_LIMIT,
            $3::uuid[]          AS USER_IDS,
            INTERVAL '6 HOURS'  AS MIN_TIME_BETWEEN_PHOTOS,
            INTERVAL '3 months' AS LOOKBACK_WINDOW
    ),

    data AS (
        SELECT
            aa.id,
            aa.ts,
            COALESCE(aa.normalized_quality_score, 0) AS normalized_quality_score
        FROM asset_analysis aa
             CROSS JOIN CONSTANTS c
        WHERE
              aa.ts >= CURRENT_TIMESTAMP - c.LOOKBACK_WINDOW
          AND aa."ownerId" = ANY (c.USER_IDS)
          AND COALESCE(aa.normalized_quality_score, 0) >= 0
    ),

    selected_assets AS (
        WITH
            weighted_data AS (
                SELECT
                    d.id,
                    d.ts,
                    1 + d.normalized_quality_score AS weight
                FROM data d
            ),

            weighted_data_running_sum AS (
                SELECT
                    wd.*,
                    SUM(wd.weight) OVER ()               AS total_weight,
                    SUM(wd.weight) OVER (ORDER BY wd.ts) AS right_cumulative
                FROM weighted_data wd
            ),

            weighted_data_bands AS (
                SELECT
                    wdrs.*,
                    COALESCE(LAG(wdrs.right_cumulative) OVER (ORDER BY wdrs.ts), 0) AS left_cumulative
                FROM weighted_data_running_sum wdrs
            ),

            candidates AS (
                SELECT
                    i AS draw_number,
                    wb.id,
                    wb.ts
                FROM weighted_data_bands wb
                     CROSS JOIN CONSTANTS c
                     JOIN GENERATE_SERIES(0, 2 * c.RESULT_LIMIT) i
                          ON (((c.SEED # i)::BIGINT * 73244475::BIGINT) % 4294967296::BIGINT) % ROUND(1367 * wb.total_weight)::BIGINT
                              BETWEEN 1367 * wb.left_cumulative AND 1367 * wb.right_cumulative
            ),

            candidates_with_lookback AS (
                SELECT
                    c.draw_number,
                    c.id,
                    c.ts,
                    LAG(c.ts) OVER (ORDER BY c.ts, c.draw_number) AS prev_ts
                FROM candidates c
            ),

            filtered_candidates AS (
                SELECT
                    ROW_NUMBER() OVER (ORDER BY cwl.draw_number) AS draw_number,
                    cwl.id,
                    cwl.ts
                FROM candidates_with_lookback cwl
                     CROSS JOIN CONSTANTS c
                WHERE
                     cwl.prev_ts IS NULL
                  OR cwl.ts - cwl.prev_ts >= c.MIN_TIME_BETWEEN_PHOTOS
            )

        SELECT
            saf.draw_number,
            saf.id,
            saf.ts
        FROM filtered_candidates saf
             CROSS JOIN CONSTANTS c
        WHERE
            saf.draw_number <= c.RESULT_LIMIT
    )

SELECT
    sa.id
FROM selected_assets sa
ORDER BY sa.draw_number`;

export const memorylaneYearQuery = `WITH
    CONSTANTS AS (
        SELECT
            $1::BIGINT            AS SEED,
            $2::INT               AS RESULT_LIMIT,
            $3::uuid[]            AS USER_IDS,
            INTERVAL '15 minutes' AS MIN_TIME_BETWEEN_PHOTOS
    ),

    data AS (
        SELECT
            aa.id,
            aa.ts,
            COALESCE(aa.normalized_quality_score, 0) AS normalized_quality_score,
            EXTRACT(YEAR FROM aa.ts)                 AS year
        FROM asset_analysis aa
             CROSS JOIN CONSTANTS c
        WHERE
              aa."ownerId" = ANY (c.USER_IDS)
          AND COALESCE(aa.normalized_quality_score, 0) >= 0
    ),

    selected_year AS (
        WITH
            weighted_data AS (
                SELECT
                    d.year,
                    SQRT(COUNT(*)) AS weight
                FROM data d
                     CROSS JOIN CONSTANTS c
                GROUP BY d.year, c.RESULT_LIMIT
                HAVING
                    COUNT(*) > c.RESULT_LIMIT
            ),

            weighted_data_running_sum AS (
                SELECT
                    wd.*,
                    SUM(wd.weight) OVER ()                 AS total_weight,
                    SUM(wd.weight) OVER (ORDER BY wd.year) AS right_cumulative
                FROM weighted_data wd
            ),

            weighted_data_bands AS (
                SELECT
                    wdrs.*,
                    COALESCE(LAG(wdrs.right_cumulative) OVER (ORDER BY wdrs.year), 0) AS left_cumulative
                FROM weighted_data_running_sum wdrs
            )

        SELECT
            wdb.year
        FROM weighted_data_bands wdb
             CROSS JOIN CONSTANTS c
        WHERE
            (c.SEED % ROUND(1367 * wdb.total_weight)::BIGINT)
                BETWEEN 1367 * wdb.left_cumulative AND 1367 * wdb.right_cumulative
        LIMIT 1
    ),

    selected_assets AS (
        WITH
            weighted_data AS (
                SELECT
                    d.id,
                    d.ts,
                    1 + d.normalized_quality_score AS weight
                FROM data d
                     JOIN selected_year USING (year)
            ),

            weighted_data_running_sum AS (
                SELECT
                    wd.*,
                    SUM(wd.weight) OVER ()               AS total_weight,
                    SUM(wd.weight) OVER (ORDER BY wd.ts) AS right_cumulative
                FROM weighted_data wd
            ),

            weighted_data_bands AS (
                SELECT
                    wdrs.*,
                    COALESCE(LAG(wdrs.right_cumulative) OVER (ORDER BY wdrs.ts), 0) AS left_cumulative
                FROM weighted_data_running_sum wdrs
            ),

            candidates AS (
                SELECT
                    i AS draw_number,
                    wb.id,
                    wb.ts
                FROM weighted_data_bands wb
                     CROSS JOIN CONSTANTS c
                     JOIN GENERATE_SERIES(0, 2 * c.RESULT_LIMIT) i
                          ON (((c.SEED # i)::BIGINT * 73244475::BIGINT) % 4294967296::BIGINT) % ROUND(1367 * wb.total_weight)::BIGINT
                              BETWEEN 1367 * wb.left_cumulative AND 1367 * wb.right_cumulative
            ),

            candidates_with_lookback AS (
                SELECT
                    c.draw_number,
                    c.id,
                    c.ts,
                    LAG(c.ts) OVER (ORDER BY c.ts, c.draw_number) AS prev_ts
                FROM candidates c
            ),

            filtered_candidates AS (
                SELECT
                    ROW_NUMBER() OVER (ORDER BY cwl.draw_number) AS draw_number,
                    cwl.id,
                    cwl.ts
                FROM candidates_with_lookback cwl
                     CROSS JOIN CONSTANTS c
                WHERE
                     cwl.prev_ts IS NULL
                  OR cwl.ts - cwl.prev_ts >= c.MIN_TIME_BETWEEN_PHOTOS
            )

        SELECT
            saf.draw_number,
            saf.id,
            saf.ts
        FROM filtered_candidates saf
             CROSS JOIN CONSTANTS c
        WHERE
            saf.draw_number <= c.RESULT_LIMIT
    )

SELECT
    sa.id,
    s.year
FROM selected_assets sa
     CROSS JOIN selected_year s
ORDER BY sa.ts`;

export const migration1735468387695CreateAssetAnalysis = `CREATE MATERIALIZED VIEW asset_analysis AS
WITH
    final AS (
        SELECT
            lp.id,
            lp."ownerId",
            lp.ts,

            /* add cluster info */
            lp.cluster_id,
            COALESCE(cs.cluster_cardinality, 0)                   AS cluster_cardinality,
            COALESCE(cs.cluster_cardinality_score_ge_0, 0)        AS cluster_cardinality_score_ge_0,
            COALESCE(cs.cluster_cardinality_score_ge_1, 0)        AS cluster_cardinality_score_ge_1,
            COALESCE(cs.cluster_start, lp.ts)                     AS cluster_start,
            COALESCE(cs.cluster_end, lp.ts)                       AS cluster_end,
            COALESCE(cs.cluster_duration, INTERVAL '0')           AS cluster_duration,
            lp.is_core,
            lp.is_noise,
            lp.is_border,
            CASE WHEN lp.is_noise THEN 'noise' ELSE 'cluster' END AS label,

            /* add location data from exif */
            e.city,
            e.state,
            e.country,

            /* add quality scores - both raw and normalized using window functions */
            q.score                                               AS quality_score,
            CASE
                WHEN q.score IS NOT NULL AND STDDEV(q.score) OVER (PARTITION BY lp."ownerId") != 0
                    THEN (q.score - AVG(q.score) OVER (PARTITION BY lp."ownerId")) / STDDEV(q.score) OVER (PARTITION BY lp."ownerId")
                END                                               AS normalized_quality_score,

            /* time-based density metrics */
            COUNT(*) FILTER (WHERE TRUE) OVER (
                PARTITION BY lp."ownerId"
                ORDER BY lp.ts
                RANGE BETWEEN INTERVAL '5 minutes' PRECEDING AND INTERVAL '5 minutes' FOLLOWING
                )                                                 AS neighbors_5m,

            COUNT(*) FILTER (WHERE TRUE) OVER (
                PARTITION BY lp."ownerId"
                ORDER BY lp.ts
                RANGE BETWEEN INTERVAL '1 hour' PRECEDING AND INTERVAL '1 hour' FOLLOWING
                )                                                 AS neighbors_1h,

            COUNT(*) FILTER (WHERE TRUE) OVER (
                PARTITION BY lp."ownerId"
                ORDER BY lp.ts
                RANGE BETWEEN INTERVAL '1 day' PRECEDING AND INTERVAL '1 day' FOLLOWING
                )                                                 AS neighbors_1d,

            COUNT(*) FILTER (WHERE TRUE) OVER (
                PARTITION BY lp."ownerId"
                ORDER BY lp.ts
                RANGE BETWEEN INTERVAL '7 days' PRECEDING AND INTERVAL '7 days' FOLLOWING
                )                                                 AS neighbors_7d,

            COUNT(*) FILTER (WHERE TRUE) OVER (
                PARTITION BY lp."ownerId"
                ORDER BY lp.ts
                RANGE BETWEEN INTERVAL '30 days' PRECEDING AND INTERVAL '30 days' FOLLOWING
                )                                                 AS neighbors_30d,

            COUNT(*) FILTER (WHERE TRUE) OVER (
                PARTITION BY lp."ownerId"
                ORDER BY lp.ts
                RANGE BETWEEN INTERVAL '180 days' PRECEDING AND INTERVAL '180 days' FOLLOWING
                )                                                 AS neighbors_180d

        FROM asset_dbscan lp
             LEFT JOIN asset_dbscan_clusters cs ON lp.cluster_id = cs.cluster_id
             LEFT JOIN exif e ON lp.id = e."assetId"
             LEFT JOIN quality_assessments q ON lp.id = q."assetId"
    )
SELECT *
FROM final;`;

export const migration1735468387695CreateAssetDbscan = `CREATE MATERIALIZED VIEW asset_dbscan AS
WITH
    data AS (
        SELECT DISTINCT ON (COALESCE(a."duplicateId", a.id), a."ownerId")
            a.id,
            a."ownerId",
            a."localDateTime" AS ts,
            c.classification,
            c.coordinates
        FROM assets a
             JOIN asset_photo_classification c ON a.id = c.id
        WHERE
            "deletedAt" IS NULL
        ORDER BY COALESCE(a."duplicateId", a.id),
                 a."ownerId",
                 a.id
    ),

    home_core_clusters AS (
        WITH
            time_points AS (
                SELECT
                    d.*,
                    COUNT(*) OVER (
                        PARTITION BY d."ownerId"
                        ORDER BY d.ts
                        RANGE BETWEEN INTERVAL '1 day' PRECEDING AND INTERVAL '1 day' FOLLOWING
                        ) AS neighbor_count
                FROM data d
                WHERE
                    classification IN ('home', 'unknown')
            ),
            ordered_core AS (
                SELECT
                    tp.*,
                    LAG(tp.ts) OVER (PARTITION BY tp."ownerId" ORDER BY tp.ts) AS prev_ts
                FROM time_points tp
                WHERE
                    tp.neighbor_count >= 10 -- MinPts=10
            )
        SELECT
            oc.id,
            oc."ownerId",
            oc.ts,
            oc.classification,
            TRUE  AS is_core,
            SUM(CASE WHEN (oc.ts - oc.prev_ts) > INTERVAL '1 day' THEN 1 ELSE 0 END) OVER (
                PARTITION BY oc."ownerId"
                ORDER BY oc.ts
                ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                ) AS core_cluster_id
        FROM ordered_core oc
    ),

    trip_core_clusters AS (
        WITH
            time_points AS (
                SELECT
                    d.*,
                    COUNT(*) OVER (
                        PARTITION BY d."ownerId"
                        ORDER BY d.ts
                        RANGE BETWEEN INTERVAL '7 days' PRECEDING AND INTERVAL '7 days' FOLLOWING
                        ) AS neighbor_count
                FROM data d
                WHERE
                    classification = 'trip'
            ),
            ordered_core AS (
                SELECT
                    tp.*,
                    LAG(tp.ts) OVER (PARTITION BY tp."ownerId" ORDER BY tp.ts)          AS prev_ts,
                    LAG(tp.coordinates) OVER (PARTITION BY tp."ownerId" ORDER BY tp.ts) AS prev_coord
                FROM time_points tp
                WHERE
                    tp.neighbor_count >= 50 -- MinPts=50
            )
        SELECT
            oc.id,
            oc."ownerId",
            oc.ts,
            oc.classification,
            TRUE  AS is_core,
            SUM(CASE
                    WHEN (oc.ts - oc.prev_ts) > INTERVAL '7 days' THEN 1
                    WHEN (earth_distance(oc.coordinates, oc.prev_coord)) > 500000 THEN 1 -- basic bridge detection
                    ELSE 0
                END) OVER (
                PARTITION BY oc."ownerId"
                ORDER BY oc.ts
                ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                ) AS core_cluster_id
        FROM ordered_core oc
    ),

    trip_core_cluster_stats AS (
        SELECT
            core_cluster_id,
            "ownerId",
            TRUE    AS is_core,
            MIN(ts) AS core_cluster_start,
            MAX(ts) AS core_cluster_end
        FROM trip_core_clusters
        GROUP BY core_cluster_id, "ownerId"
        HAVING
            COUNT(*) > 20
    ),

    assign_unknown_to_overlapping_trip AS (
        SELECT
            id,
            TRUE                   AS assigned_to_trip_core,
            MIN(s.core_cluster_id) AS trip_core_cluster_id
        FROM data d
             JOIN trip_core_cluster_stats s ON s."ownerId" = d."ownerId"
        WHERE
              classification = 'unknown'
          AND ts BETWEEN core_cluster_start AND core_cluster_end
        GROUP BY id
    ),

    all_points AS (
        SELECT
            d.id,
            d."ownerId",
            d.ts,
            d.classification,
            hc.core_cluster_id                                                             AS home_core_cluster_id,
            COALESCE(hc.is_core, FALSE) AND NOT COALESCE(rcu.assigned_to_trip_core, FALSE) AS is_home_core,
            COALESCE(tcc.core_cluster_id, rcu.trip_core_cluster_id)                        AS trip_core_cluster_id,
            COALESCE(tcc.is_core, rcu.assigned_to_trip_core, FALSE)                        AS is_trip_core
        FROM data d
             LEFT JOIN home_core_clusters hc USING (id)
             LEFT JOIN trip_core_clusters tc USING (id)
             LEFT JOIN assign_unknown_to_overlapping_trip rcu USING (id)
             LEFT JOIN trip_core_cluster_stats tcc
                       ON tc.core_cluster_id = tcc.core_cluster_id AND tc."ownerId" = tcc."ownerId"
    ),

    rerank_cluster_id AS (
        SELECT
            id,
            "ownerId",
            ts,
            classification,
            CASE
                WHEN is_home_core THEN 2 * home_core_cluster_id
                WHEN is_trip_core THEN 2 * trip_core_cluster_id + 1
                ELSE -1
                END                      AS cluster_id,
            is_trip_core OR is_home_core AS is_core
        FROM all_points
    ),


    labeled_points AS (
        SELECT
            cca.id,
            cca."ownerId",
            cca.ts,
            cca.cluster_id,
            (cca.cluster_id = -1)                      AS is_noise,
            cca.is_core,
            (NOT cca.is_core AND cca.cluster_id != -1) AS is_border
        FROM rerank_cluster_id cca
    )
SELECT *
FROM labeled_points;`;

export const migration1735468387695CreateAssetDbscanClusters = `CREATE MATERIALIZED VIEW asset_dbscan_clusters AS
WITH
    cluster_data AS (
        SELECT
            ad.cluster_id,
            ad."ownerId",
            ad.ts,
            q.score,
            COALESCE(e.city, 'unknown')    AS city,
            COALESCE(e.state, 'unknown')   AS state,
            COALESCE(e.country, 'unknown') AS country
        FROM asset_dbscan ad
             LEFT JOIN exif e ON ad.id = e."assetId"
             LEFT JOIN quality_assessments q ON ad.id = q."assetId"
    ),
    normalized_scores AS (
        SELECT
            cluster_id,
            "ownerId",
            ts,
            score,
            city,
            state,
            country,
            CASE
                WHEN score IS NOT NULL AND STDDEV(score) OVER (PARTITION BY "ownerId") != 0
                    THEN (score - AVG(score) OVER (PARTITION BY "ownerId")) / STDDEV(score) OVER (PARTITION BY "ownerId")
                ELSE NULL
                END AS normalized_score
        FROM cluster_data
    ),
    cluster_basic_stats AS (
        SELECT
            cluster_id,
            "ownerId",
            MIN(ts)                                       AS cluster_start,
            MAX(ts)                                       AS cluster_end,
            MAX(ts) - MIN(ts)                             AS cluster_duration,
            COUNT(*)                                      AS cluster_cardinality,
            COUNT(*) FILTER (WHERE normalized_score >= 0) AS cluster_cardinality_score_ge_0,
            COUNT(*) FILTER (WHERE normalized_score >= 1) AS cluster_cardinality_score_ge_1
        FROM normalized_scores cs
        WHERE
            cluster_id != -1
        GROUP BY cluster_id, "ownerId"
    ),

    cities AS (
        WITH
            city_counts AS (
                SELECT
                    cluster_id,
                    "ownerId",
                    city,
                    COUNT(*) AS city_count
                FROM normalized_scores
                WHERE
                    cluster_id != -1
                GROUP BY cluster_id, "ownerId", city
            ),
            city_totals AS (
                SELECT
                    cluster_id,
                    "ownerId",
                    COUNT(*) AS total_cities
                FROM normalized_scores
                WHERE
                    cluster_id != -1
                GROUP BY cluster_id, "ownerId"
            )
        SELECT
            cc.cluster_id,
            cc."ownerId",
            JSONB_OBJECT_AGG(cc.city, ROUND((cc.city_count::DECIMAL / ct.total_cities), 4)) AS cities
        FROM city_counts cc
             JOIN city_totals ct
                  ON cc.cluster_id = ct.cluster_id AND cc."ownerId" = ct."ownerId"
        GROUP BY cc.cluster_id, cc."ownerId"
    ),

    states AS (
        WITH
            state_counts AS (
                SELECT
                    cluster_id,
                    "ownerId",
                    state,
                    COUNT(*) AS state_count
                FROM normalized_scores
                WHERE
                    cluster_id != -1
                GROUP BY cluster_id, "ownerId", state
            ),
            state_totals AS (
                SELECT
                    cluster_id,
                    "ownerId",
                    COUNT(*) AS total_states
                FROM normalized_scores
                WHERE
                    cluster_id != -1
                GROUP BY cluster_id, "ownerId"
            )
        SELECT
            sc.cluster_id,
            sc."ownerId",
            JSONB_OBJECT_AGG(sc.state, ROUND((sc.state_count::DECIMAL / st.total_states), 4)) AS states
        FROM state_counts sc
             JOIN state_totals st
                  ON sc.cluster_id = st.cluster_id AND sc."ownerId" = st."ownerId"
        GROUP BY sc.cluster_id, sc."ownerId"
    ),

    countries AS (
        WITH
            country_counts AS (
                SELECT
                    cluster_id,
                    "ownerId",
                    country,
                    COUNT(*) AS country_count
                FROM normalized_scores
                WHERE
                    cluster_id != -1
                GROUP BY cluster_id, "ownerId", country
            ),
            country_totals AS (
                SELECT
                    cluster_id,
                    "ownerId",
                    COUNT(*) AS total_countries
                FROM normalized_scores
                WHERE
                    cluster_id != -1
                GROUP BY cluster_id, "ownerId"
            )
        SELECT
            cc.cluster_id,
            cc."ownerId",
            JSONB_OBJECT_AGG(cc.country, ROUND((cc.country_count::DECIMAL / ct.total_countries), 4)) AS countries
        FROM country_counts cc
             JOIN country_totals ct
                  ON cc.cluster_id = ct.cluster_id AND cc."ownerId" = ct."ownerId"
        GROUP BY cc.cluster_id, cc."ownerId"
    ),

    cluster_location_distribution AS (
        SELECT
            cb.cluster_id,
            cb."ownerId",
            COALESCE(ci.cities, '{}'::JSONB)    AS cities,
            COALESCE(st.states, '{}'::JSONB)    AS states,
            COALESCE(ct.countries, '{}'::JSONB) AS countries
        FROM cluster_basic_stats cb
             LEFT JOIN cities ci ON cb.cluster_id = ci.cluster_id AND cb."ownerId" = ci."ownerId"
             LEFT JOIN states st ON cb.cluster_id = st.cluster_id AND cb."ownerId" = st."ownerId"
             LEFT JOIN countries ct ON cb.cluster_id = ct.cluster_id AND cb."ownerId" = ct."ownerId"
    ),

    cluster_stats_with_location AS (
        SELECT
            cb.cluster_id,
            cb."ownerId",
            cb.cluster_start,
            cb.cluster_end,
            cb.cluster_duration,
            cb.cluster_cardinality,
            cb.cluster_cardinality_score_ge_0,
            cb.cluster_cardinality_score_ge_1,
            cld.cities,
            cld.states,
            cld.countries
        FROM cluster_basic_stats cb
             LEFT JOIN cluster_location_distribution cld
                       ON cb.cluster_id = cld.cluster_id AND cb."ownerId" = cld."ownerId"
    )

SELECT *
FROM cluster_stats_with_location;`;

export const migration1735468387695CreateAssetHomeDetection = `CREATE OR REPLACE VIEW asset_home_detection AS
WITH

-- 1) Some parameters
constants AS (
    SELECT
        5000  AS radius_m,    -- 5 km radius
        0.005 AS deg_per_bin, -- latitude/longitude bin factor
        25    AS bin_delta -- upper bound for radius expressed as bin widths

    -- the math looks as follows:
    -- 1km ≈ 0.009° (equator) - 0.023° (Reykjavik)
    -- → Δ = 0.005° ≈ 556m - 2556m (bin width)
    -- → 5km ≈ 0.045° - 0.115° → Δ ≈ 9 - 23 bins
),

data AS (
    SELECT
        a.id,
        a."ownerId",
        a."localDateTime" AS ts,
        e.latitude,
        e.longitude
    FROM assets a
         JOIN exif e ON a.id = e."assetId"
    WHERE
          a."deletedAt" IS NULL
      AND e.latitude IS NOT NULL
      AND e.longitude IS NOT NULL
),

binned_data AS (
    SELECT
        id,
        "ownerId",
        latitude,
        longitude,

        DATE_TRUNC('day', ts)          AS sector_ts_bin_day,
        FLOOR(latitude / deg_per_bin)  AS latitude_bin,
        FLOOR(longitude / deg_per_bin) AS longitude_bin
    FROM data
         CROSS JOIN constants c
),

sector_day AS (
    SELECT
        "ownerId",
        sector_ts_bin_day,
        latitude_bin,
        longitude_bin,
        AVG(latitude)                              AS rep_latitude,  -- representative latitude for the sector
        AVG(longitude)                             AS rep_longitude, -- representative longitude for the sector
        ll_to_earth(AVG(latitude), AVG(longitude)) AS coordinates
    FROM binned_data
    GROUP BY "ownerId", sector_ts_bin_day, latitude_bin, longitude_bin
),

sector_day_pairs AS (
    SELECT DISTINCT
        ca."ownerId",
        ca.latitude_bin,
        ca.longitude_bin,
        ca.sector_ts_bin_day AS sector_ts_bin_day,
        ph.sector_ts_bin_day AS photo_ts_bin_day
    FROM sector_day ca
         CROSS JOIN constants c
         JOIN sector_day ph
              ON ca."ownerId" = ph."ownerId"
                  AND ph.sector_ts_bin_day BETWEEN ca.sector_ts_bin_day - INTERVAL '90 DAYS' AND ca.sector_ts_bin_day + INTERVAL '90 DAYS'
                  AND ph.latitude_bin BETWEEN ca.latitude_bin - bin_delta AND ca.latitude_bin + bin_delta
                  AND ph.longitude_bin BETWEEN ca.longitude_bin - bin_delta AND ca.longitude_bin + bin_delta
                  AND earth_distance(ca.coordinates, ph.coordinates) <= radius_m
),

sector_day_scores AS (
    WITH
        sector_day_deltas AS (
            SELECT
                "ownerId",
                sector_ts_bin_day,
                latitude_bin,
                longitude_bin,
                EXTRACT(DAY FROM (photo_ts_bin_day - sector_ts_bin_day)) AS delta
            FROM sector_day_pairs
            UNION ALL
            SELECT
                "ownerId",
                sector_ts_bin_day,
                latitude_bin,
                longitude_bin,
                -90 AS delta -- left boundary
            FROM sector_day_pairs
            UNION ALL
            SELECT
                "ownerId",
                sector_ts_bin_day,
                latitude_bin,
                longitude_bin,
                +90 AS delta -- right boundary
            FROM sector_day_pairs
        ),
        sector_day_prev_deltas AS (
            SELECT
                "ownerId",
                sector_ts_bin_day,
                latitude_bin,
                longitude_bin,
                delta,
                LAG(delta) OVER (PARTITION BY "ownerId", sector_ts_bin_day, latitude_bin, longitude_bin ORDER BY delta) AS prev_delta
            FROM sector_day_deltas
        ),
        metrics AS (
            SELECT
                "ownerId",
                sector_ts_bin_day,
                latitude_bin,
                longitude_bin,

                MAX(delta - prev_delta) AS metric_max_gap,
                COUNT(delta)            AS metric_days_visited
            FROM sector_day_prev_deltas
            GROUP BY "ownerId", sector_ts_bin_day, latitude_bin, longitude_bin
        )
    SELECT
        "ownerId",
        sector_ts_bin_day,
        latitude_bin,
        longitude_bin,
        - metric_max_gap AS score,
        metric_max_gap,
        metric_days_visited
    FROM metrics
),

final AS (
    WITH
        range AS (
            SELECT
                MIN(sector_ts_bin_day) AS data_start,
                MAX(sector_ts_bin_day) AS data_end
            FROM binned_data
        ),
        monthly_best AS (
            SELECT DISTINCT ON ("ownerId", sector_ts_bin_month)
                "ownerId",
                sector_ts_bin_day,
                DATE_TRUNC('month', sector_ts_bin_day) AS sector_ts_bin_month,
                rep_latitude                           AS latitude,
                rep_longitude                          AS longitude,
                score,
                metric_max_gap,
                metric_days_visited
            FROM sector_day_scores
                 JOIN sector_day USING ("ownerId", sector_ts_bin_day, latitude_bin, longitude_bin)
            ORDER BY "ownerId", sector_ts_bin_month, score DESC, metric_days_visited DESC, rep_latitude, rep_longitude, sector_ts_bin_day
        ),
        monthly_best_extended_window AS (
            SELECT DISTINCT ON ("ownerId", ts_bin_month)
                "ownerId",
                DATE_TRUNC('month', sector_ts_bin_month + (delta * INTERVAL '1 day')) AS ts_bin_month,
                sector_ts_bin_day,
                latitude,
                longitude,
                score,
                metric_max_gap,
                metric_days_visited
            FROM monthly_best
                 CROSS JOIN GENERATE_SERIES(-65, 95) delta -- previous 3 and next 3 months (asymmetric!)
                 JOIN range ON sector_ts_bin_day + (delta * INTERVAL '1 day') BETWEEN data_start AND data_end
            ORDER BY "ownerId", ts_bin_month, score DESC, metric_days_visited DESC, latitude, longitude, sector_ts_bin_day
        )
    SELECT
        "ownerId",
        MIN(ts_bin_month)                                                AS start_day,
        MAX(DATE_TRUNC('month', ts_bin_month + (32 * INTERVAL '1 day'))) AS end_day,
        sector_ts_bin_day,
        latitude,
        longitude,
        score,
        metric_max_gap,
        metric_days_visited
    FROM monthly_best_extended_window
    GROUP BY "ownerId", sector_ts_bin_day, latitude, longitude, score, metric_max_gap, metric_days_visited
)
SELECT
    "ownerId",
    start_day,
    end_day,
    sector_ts_bin_day,
    latitude,
    longitude,
    score,
    metric_max_gap,
    metric_days_visited
FROM final
ORDER BY start_day;`;

export const migration1735468387695CreateAssetPhotoClassification = `CREATE OR REPLACE VIEW asset_photo_classification AS
WITH
    constants AS (
        SELECT
            100000::float8 AS home_radius_meters -- 100 km in meters
    ),
    home_coords AS (
        SELECT
            "ownerId",
            ll_to_earth(latitude, longitude) AS coordinates,
            start_day                        AS start,
            end_day                          AS end
        FROM asset_home_detection
    ),
    enriched_assets AS (
        SELECT
            a.id,
            a."ownerId",
            a."localDateTime" AS ts,
            e.latitude        AS exif_latitude,
            e.longitude       AS exif_longitude,
            CASE
                WHEN e.latitude IS NOT NULL AND e.longitude IS NOT NULL THEN ll_to_earth(e.latitude, e.longitude)
                END           AS coordinates
        FROM assets a
             LEFT JOIN exif e ON a.id = e."assetId"
        WHERE
            a."deletedAt" IS NULL
    ),
    min_distances AS (
        SELECT
            a.id,
            MIN(earth_distance(a.coordinates, h.coordinates)) AS min_distance_meters
        FROM enriched_assets a
             LEFT JOIN home_coords h ON a."ownerId" = h."ownerId" AND a.ts BETWEEN h.start AND h.end
        WHERE
            a.coordinates IS NOT NULL
        GROUP BY a.id
    )
SELECT
    d.id,
    d."ownerId",
    d.ts,
    d.exif_latitude,
    d.exif_longitude,
    d.coordinates,
    md.min_distance_meters AS distance_meters,
    CASE
        WHEN md.min_distance_meters IS NULL
            THEN 'unknown'
        WHEN md.min_distance_meters <= c.home_radius_meters
            THEN 'home'
        ELSE 'trip'
        END                AS classification
FROM enriched_assets d
     LEFT JOIN min_distances md ON d.id = md.id
     CROSS JOIN constants c;`;
